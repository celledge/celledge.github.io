<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Firmware | Four Bits Per Nybble]]></title>
  <link href="http://chris.elledge.org/blog/categories/firmware/atom.xml" rel="self"/>
  <link href="http://chris.elledge.org/"/>
  <updated>2013-09-21T10:48:45-04:00</updated>
  <id>http://chris.elledge.org/</id>
  <author>
    <name><![CDATA[Chris Elledge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Micro-Controller Architecture 102]]></title>
    <link href="http://chris.elledge.org/blog/2013/09/08/micro-controller-architecture-102/"/>
    <updated>2013-09-08T08:37:00-04:00</updated>
    <id>http://chris.elledge.org/blog/2013/09/08/micro-controller-architecture-102</id>
    <content type="html"><![CDATA[<p>In addition to the Flash and RAM on the micro-controller, there is a
chunk of address space dedicated to the peripheral registers. These
registers provide the interface to all the peripherals which are
probably the reason that you chose the mirco-controller. There are two
ways that the peripheral registers can be addressed. The first is via
memory access. Usually there is a dedicated hole in the memory space
which addresses these registers instead of RAM. That means that load
and store instructions to these addresses will handle reading and
writing to the peripheral registers.</p>

<p>The second approach is via special instructions. The AVR uses this
approach to access the lowest registers. The intention is for these to
be the most commonly used ones, but it never seems to work out that
way. The limited number of registers that can be accessed this way is
because there are only a few bits available in the opcode to act as
addressing for the instruction. In order to access all the other
registers, they must be addressed by the first approach. On the AVR
this method only take one instruction while the first can take 3. Two
instructions to setup an address pointer and one for the load or store
immediate. Thankfully, the gcc compiler will handle figuring this one
out for you.</p>

<p>The small PICs have their own oddities as well. Instead of using 16
bit addresses to access RAM, they rely on a concept of memory
banks. In order to access memory, a bank has to be set which
determines what memory can be addressed using the load and store
instructions. For each bank, there is a chunk of addresses devoted to
registers, followed by RAM, and a small chunk of common RAM. The
common RAM is the only part that is the same no matter which bank is
selected. Accessing memory that is all in the same bank is compact,
but if several items need to be transfered between pages then a lot of
instructions are wasted shuttling the values between banks.</p>

<p>Typically Flash is read only by the instruction fetcher based off of
the program counter. However when writing to Flash you often need to
consider that it is composed of what are known as blocks and pages. A
block is a chunk of Flash memory which has to be erased as one unit. A
page is a piece of Flash which has to be written as one
unit. Typically a block contains more than one page. If you never plan
on writing self modifying code (bootloaders) then you will probably
never need to worry about this. But if you need to change portions of
the Flash you will need to handle erasing at the block level and
writing at the page level. If you wish to modify only parts of the
Flash, then you will have to store the previous values, erase the
block, and rewrite all the pages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Micro-Controller Architecture 101]]></title>
    <link href="http://chris.elledge.org/blog/2013/09/05/micro-controller-architecture-101/"/>
    <updated>2013-09-05T21:35:00-04:00</updated>
    <id>http://chris.elledge.org/blog/2013/09/05/micro-controller-architecture-101</id>
    <content type="html"><![CDATA[<p>Modern micro-controllers are basically Systems on a Chip (SOC) with
memory integrated into the package as well. The lack of external
memory buses allows for smaller packages and pin counts. It also
greatly simplifies the use of these parts.</p>

<p>Many smaller micros (PIC16, PIC24, AVR) are setup in what is known as
the Harvard Architecture. This means that the executable memory and
data memory are completely separated. Instructions cannot be executed
from the data memory, and the different memory sections can be
addressed in completely different ways.</p>

<p>Usually the executable memory is on Flash or ROM (rarely now
days). While the processor is able to directly fetch instructions from
Flash, there is typically no way to directly read variables from
it. Usually special retrieval instructions or address remapping are
needed. Some compilers will automatically use the constructs for any
constant variable reads.</p>

<p>Furthermore, Flash and RAM don&rsquo;t even need to have the same line
size. The PIC16F series has 14 bit instruction lines and 8 bit data
lines. The PIC24F series has 24 bit instruction lines and 16 bit data
lines. The AVR has 16 bit instruction lines and 8 bit data lines. The
odd flash word sizes can often make constant storage complicated. The
compilers for the two PICs usually store constants in just the bottom
8 or 16 bits of a line thus wasting big chunks of Flash if you use
lots of constants. If you want to make full use of the storage, you
must use the Flash peripheral registers instead of the simpler address
remapping that the compiler uses. While the alignments are much
cleaner on the AVR, all Flash data reads have to be done with a
special load instruction. So it falls in between the two PIC methods in
complexity.</p>

<p>Details on these operations are a topic for a future post. Next time I will cover Peripheral Registers, Flash Pages, and Memory Banks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Treatise on Firmare Development]]></title>
    <link href="http://chris.elledge.org/blog/2013/09/04/a-treatise-on-firmare-development/"/>
    <updated>2013-09-04T21:29:00-04:00</updated>
    <id>http://chris.elledge.org/blog/2013/09/04/a-treatise-on-firmare-development</id>
    <content type="html"><![CDATA[<p>I plan to write several articles on the core concepts of firmware
development and move into more advanced topics. For the simple
concepts I will probably be mostly referring to AVR processors due to
Atmel&rsquo;s freely available toolchain and their common use in Arduino
designs. As I move into the more advanced concepts I will probably
move on to other processors including various ARM processors.</p>

<h3>Planned Core Concepts</h3>

<ul>
<li>Micro-controller Architectures</li>
<li>Assembly and C Compilers</li>
<li>Registers</li>
<li>Common Peripherals</li>
<li>Interrupts</li>
</ul>


<h3>Planned Advanced Topics</h3>

<ul>
<li>Direct Memory Access</li>
<li>Asynchronous Programming</li>
<li>Real Time Operating Systems</li>
<li>Power Management</li>
<li>Fixed Point Math</li>
</ul>


<p>There are plenty of other resources for getting started with
micro-controller programming for all kinds of chips, so I plan to skip
any kind of introduction to coding in C and examples on getting
started with a particular micro-controller. Instead I will mainly be
going into the theory of operation on these topics in the hope that
with that knowledge it will be easier to take the examples available
in the wild and tame them to your needs. The intended audience is
expected to have a software engineering background.</p>
]]></content>
  </entry>
  
</feed>
